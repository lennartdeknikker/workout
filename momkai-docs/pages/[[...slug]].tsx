import { indexedFilePaths, PAGES_PATH } from "@/utils/mdx";
import fs from "fs";
import { NextPageWithLayout } from "./_app";
import { GetStaticPropsContext } from "next";
import matter from "gray-matter";
import { MDXRemote } from "next-mdx-remote";
import { serialize } from "next-mdx-remote/serialize";
import path from "path";

// Layouts
import Default from "@/layouts/Default/Default";
import Index from "@/layouts/Index/Index";

// Components
import ComponentTemplate from "@/components/ComponentTemplate/ComponentTemplate";
import Icon from "@/components/Icon/Icon";
import Image from "next/image";

const Page: NextPageWithLayout = (props: any) => {
  return (
    <MDXRemote
      {...props}
      components={{
        ComponentTemplate,
        Icon,
        Image
      }}
    />
  );
};

// https://nextjs.org/docs/basic-features/layouts#per-page-layouts
Page.getLayout = (page) => {
  switch (page?.props?.scope?.layout) {
    case "index":
      return <Index {...page.props}>{page}</Index>;
    default:
      return <Default {...page.props}>{page}</Default>;
  }
};

export async function getStaticProps(context: GetStaticPropsContext) {
  // Map the page route params to the mdx file location string: ['page', 'with-content'] => page/with-content
  const slugArray =
    typeof context?.params?.slug !== "string" ? context?.params?.slug : [];
  let isIndexPage = !slugArray
  const pageContentPath = path.join(
    PAGES_PATH,
    `${slugArray?.join("/") || "index"}`
  );

  // With that path, get the file content for the current route.
  // If a path does not exist as a file,
  // check if an index file embedded in a folder exists for that path and use that content.
  let source = null;
  if (fs.existsSync(`${pageContentPath}.mdx`))
    source = fs.readFileSync(`${pageContentPath}.mdx`);
  else if (fs.existsSync(`${pageContentPath}/index.mdx`))
    source = fs.readFileSync(`${pageContentPath}/index.mdx`);
    isIndexPage = true

  // Return a 404 if the path is rendered, but there's no content.
  if (!source) {
    return {
      notFound: true,
    };
  }

  // Parse the Markdown content using the matter package.
  const { content, data } = matter(source);
  // Serialize data before sending it to the page.
  const mdxSource = await serialize(content, { scope: data });
  return {
    props: {
      ...mdxSource,
      indexedPaths: isIndexPage
        ? indexedFilePaths
            .map((path: string) => path.replace(/\.mdx?$/, ""))
            .map((path: string) => path.replace("/index", ""))
        : [],
    },
  };
}

export async function getStaticPaths() {
  // Define the paths that can be statically generated by going over the content folder structure.
  let paths = indexedFilePaths
    // Remove file extensions for page paths
    .map((path: string) => path.replace(/\.mdx?$/, ""))
    // Convert the path to an array and remove 'index' from it, because we don't want that in the url.
    .map((path: string) =>
      path.split("/").filter((pathPart: string) => pathPart !== "index")
    )
    // Map the path into the static paths object required by Next.js
    .map((path: string) => ({ params: { slug: path } }));

  return {
    paths,
    fallback: false,
  };
}

export default Page;
